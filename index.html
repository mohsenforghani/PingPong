<!doctype html>
<html lang="fa">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=1,user-scalable=no" />
<title>PingPong - Mohsen Forghani</title>
<style>
  html,body{height:100%;margin:0;padding:0;background:#000;color:#fff;font-family:tahoma, Arial;overflow:hidden;}
  #gameCanvas{display:block;touch-action:none; margin:0 auto; background:#000;}
  #scoreBox{position:absolute;top:10px;width:100%;text-align:center;font-size:24px;pointer-events:none;}
  #statusText{position:absolute;bottom:14px;width:100%;text-align:center;font-size:14px;}
  #menu{position:absolute;top:30%;left:50%;transform:translate(-50%,-50%);text-align:center;z-index:10;}
  button{background:#222;top:60%;left:50%;color:#fff;border:1px solid #666;padding:10px 18px;margin:6px;font-size:16px;border-radius:8px;}
</style>
</head>
<body>
<canvas id="gameCanvas"></canvas>
<div id="scoreBox"></div>
<div id="statusText"></div>

<div id="menu">
  <button id="wantBtn">من آماده بازی هستم</button>
  <button id="startBtn" style="display:none">یک بازیکن آماده است. بازی شروع شود</button>
  <button id="cancelBtn" style="display:none">لغو انتظار</button>
</div>

<script>
// CONFIG
const WS_URL = 'wss://pingpong-te0t.onrender.com';
const LOGICAL_W = 450, LOGICAL_H = 800;
const INTERP_MS = 50;
const SEND_THROTTLE = 10;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let ws = null;
let playerId = null;
let gameStarted = false;
let gameState = null;          // authoritative state from server
let renderBall = { x: LOGICAL_W/2, y: LOGICAL_H/2 };
let renderPaddles = [{ x: LOGICAL_W/2-50, y:10 }, { x: LOGICAL_W/2-50, y:LOGICAL_H-30 }];
let lastSendTs = 0;
let stateBuffer = [];

// Canvas resize
function resizeCanvas() {
  const ratio = window.devicePixelRatio || 1;
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;
  const gameRatio = LOGICAL_W / LOGICAL_H;
  const screenRatio = screenW / screenH;

  let renderW, renderH;
  if (screenRatio > gameRatio) { renderH = screenH; renderW = renderH * gameRatio; }
  else { renderW = screenW; renderH = renderW / gameRatio; }

  canvas.style.width = renderW + 'px';
  canvas.style.height = renderH + 'px';
  canvas.width = Math.round(renderW * ratio);
  canvas.height = Math.round(renderH * ratio);
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// clientX -> logical X
function clientXToLogical(clientX) {
  const ratio = window.devicePixelRatio || 1;
  const displayW = canvas.width / ratio;
  const displayH = canvas.height / ratio;
  const scale = Math.min(displayW / LOGICAL_W, displayH / LOGICAL_H);
  const offsetX = (displayW - LOGICAL_W * scale) / 2;
  return (clientX - offsetX) / scale;
}

// WebSocket connect
function connect() {
  if (ws) ws.close();
  ws = new WebSocket(WS_URL);
  ws.onopen = () => console.log('Connected');
  ws.onmessage = onMessage;
  ws.onclose = () => setTimeout(connect, 1000);
}
connect();

function send(obj) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(JSON.stringify(obj));
}

// Paddle sending with client prediction
function sendPaddle(logicalX) {
  const now = Date.now();
  if (now - lastSendTs < SEND_THROTTLE) return;
  lastSendTs = now;
  const maxLeft = LOGICAL_W - 100;
  const clamped = Math.max(0, Math.min(maxLeft, logicalX));
  if (typeof playerId === 'number') renderPaddles[playerId].x = clamped;
  send({ type: 'paddle', x: +clamped.toFixed(2) });
}

// Input
document.addEventListener('mousemove', e => {
  if (!gameStarted) return;
  const lx = clientXToLogical(e.clientX);
  sendPaddle(lx - 50);
});
document.addEventListener('touchmove', e => {
  if (!gameStarted) return;
  e.preventDefault();
  const lx = clientXToLogical(e.touches[0].clientX);
  sendPaddle(lx - 50);
}, {passive:false});

// Interpolation
function interpolateState(renderTs) {
  if (stateBuffer.length === 0) return null;
  let i = 0;
  while (i < stateBuffer.length && stateBuffer[i].ts <= renderTs) i++;
  if (i === 0) return stateBuffer[0].state;
  if (i >= stateBuffer.length) return stateBuffer[stateBuffer.length - 1].state;
  const a = stateBuffer[i-1], b = stateBuffer[i];
  const t = (renderTs - a.ts) / Math.max(1, (b.ts - a.ts));
  const lerp = (v0, v1, t) => v0 + (v1 - v0) * t;
  return {
    ball: { x: lerp(a.state.ball.x, b.state.ball.x, t), y: lerp(a.state.ball.y, b.state.ball.y, t), r: a.state.ball.r },
    paddles: [
      { x: lerp(a.state.paddles[0].x, b.state.paddles[0].x, t), y: a.state.paddles[0].y, w: a.state.paddles[0].w, h: a.state.paddles[0].h },
      { x: lerp(a.state.paddles[1].x, b.state.paddles[1].x, t), y: a.state.paddles[1].y, w: a.state.paddles[1].w, h: a.state.paddles[1].h }
    ],
    scores: a.state.scores
  };
}

// Render loop
function drawLoop() {
  const ratio = window.devicePixelRatio || 1;
  const displayW = canvas.width / ratio;
  const displayH = canvas.height / ratio;
  ctx.clearRect(0,0,displayW,displayH);

  const scaleX = displayW / LOGICAL_W;
  const scaleY = displayH / LOGICAL_H;
  const offsetX = (displayW - LOGICAL_W * scaleX) / 2;
  const offsetY = (displayH - LOGICAL_H * scaleY) / 2;

  const renderTs = Date.now() - INTERP_MS;
  let drawState = gameState ? interpolateState(renderTs) : null;

  if (drawState) {
    renderBall.x = drawState.ball.x;
    renderBall.y = drawState.ball.y;

    // draw ball
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(offsetX + renderBall.x * scaleX, offsetY + renderBall.y * scaleY,
            Math.max(2, drawState.ball.r * Math.min(scaleX, scaleY)), 0, Math.PI*2);
    ctx.fill();

    // draw paddles
    drawState.paddles.forEach((p, i) => {
      if (typeof playerId === 'number' && i === playerId) {
        // predicted paddle
        renderPaddles[i].x += (renderPaddles[i].x - renderPaddles[i].x) * 0;
      } else {
        renderPaddles[i].x += (p.x - renderPaddles[i].x) * 0.28;
      }
      renderPaddles[i].y = p.y;
      ctx.fillRect(offsetX + renderPaddles[i].x * scaleX, offsetY + renderPaddles[i].y * scaleY,
                   p.w * scaleX, p.h * scaleY);
    });

    // draw score
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.max(12, Math.round(20 * Math.min(scaleX, scaleY)))}px Tahoma`;
    ctx.textAlign = 'center';
    ctx.fillText(`${drawState.scores[0]} - ${drawState.scores[1]}`, displayW/2, offsetY + 26);
  } else {
    ctx.fillStyle = '#fff';
    ctx.font = '16px Tahoma';
    ctx.textAlign = 'center';
    ctx.fillText('در انتظار شروع بازی...', displayW/2, displayH/2);
  }

  requestAnimationFrame(drawLoop);
}
requestAnimationFrame(drawLoop);

// Menu buttons
document.getElementById('wantBtn').onclick = () => {
    send({ type: 'waitForPlayer' });
    document.getElementById('wantBtn').style.display = 'none';
    document.getElementById('cancelBtn').style.display = 'inline-block';
};

document.getElementById('cancelBtn').onclick = () => {
    send({ type: 'cancelWait' });
    document.getElementById('wantBtn').style.display = 'inline-block';
    document.getElementById('cancelBtn').style.display = 'none';
};

document.getElementById('startBtn').onclick = () => {
    send({ type: 'acceptMatch' });
    document.getElementById('startBtn').style.display = 'none';
};

// Handle server messages
function onMessage(e) {
  let data;
  try { data = JSON.parse(e.data); } catch { return; }
  const t = data.type;

  if (t === 'assign') playerId = data.playerId;
  if (t === 'start') gameStarted = true;

  if (t === 'state') {
    const s = data.state;
    const serverTs = data.meta?.ts || Date.now();
    stateBuffer.push({ ts: serverTs, state: s });
    while (stateBuffer.length > 10) stateBuffer.shift();
    gameState = s;
  }

  if (t === 'lobby') {
    if (data.status === 'no_waiting') {
        document.getElementById('statusText').innerText = 'هیچ بازیکنی منتظر نیست';
        document.getElementById('wantBtn').style.display = 'inline-block';
        document.getElementById('cancelBtn').style.display = 'none';
        document.getElementById('startBtn').style.display = 'none';
    } else if (data.status === 'waiting_for_opponent') {
        document.getElementById('statusText').innerText = 'منتظر بازیکن دیگر...';
        document.getElementById('wantBtn').style.display = 'none';
        document.getElementById('cancelBtn').style.display = 'inline-block';
        document.getElementById('startBtn').style.display = 'none';
    } else if (data.status === 'someone_waiting') {
        document.getElementById('statusText').innerText = 'یک بازیکن منتظر است. بازی را شروع کنید.';
        if (playerId !== null) document.getElementById('startBtn').style.display = 'inline-block';
    }
  }

  if (t === 'ping') send({ type: 'pong', ts: Date.now() });
}
</script>

</body>
</html>
