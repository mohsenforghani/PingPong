<script>
// CONFIG
const WS_URL = 'wss://pingpong-te0t.onrender.com';
const LOGICAL_W = 450, LOGICAL_H = 800;
const INTERP_MS = 50;
const SEND_THROTTLE = 10;

const canvas = document.getElementById('gameCanvas');
const ctx = canvas.getContext('2d');

let ws = null;
let playerId = null;
let gameStarted = false;
let gameState = null;          // authoritative state from server
let renderBall = { x: LOGICAL_W/2, y: LOGICAL_H/2 };
let renderPaddles = [{ x: LOGICAL_W/2-50, y:10 }, { x: LOGICAL_W/2-50, y:LOGICAL_H-30 }];
let lastSendTs = 0;
let stateBuffer = [];

function resizeCanvas() {
  const ratio = window.devicePixelRatio || 1;
  const screenW = window.innerWidth;
  const screenH = window.innerHeight;
  const gameRatio = LOGICAL_W / LOGICAL_H;
  const screenRatio = screenW / screenH;

  let renderW, renderH;
  if (screenRatio > gameRatio) { renderH = screenH; renderW = renderH * gameRatio; }
  else { renderW = screenW; renderH = renderW / gameRatio; }

  canvas.style.width = renderW + 'px';
  canvas.style.height = renderH + 'px';
  canvas.width = Math.round(renderW * ratio);
  canvas.height = Math.round(renderH * ratio);
  ctx.setTransform(ratio,0,0,ratio,0,0);
}
window.addEventListener('resize', resizeCanvas);
resizeCanvas();

// convert clientX -> logicalX
function clientXToLogical(clientX) {
  const ratio = window.devicePixelRatio || 1;
  const displayW = canvas.width / ratio;
  const displayH = canvas.height / ratio;
  const scale = Math.min(displayW / LOGICAL_W, displayH / LOGICAL_H);
  const offsetX = (displayW - LOGICAL_W * scale) / 2;
  return (clientX - offsetX) / scale;
}

// WebSocket
function connect() {
  if (ws) ws.close();
  ws = new WebSocket(WS_URL);
  ws.onopen = () => console.log('Connected');
  ws.onmessage = onMessage;
  ws.onclose = () => setTimeout(connect, 1000);
}
connect();

function send(obj) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(JSON.stringify(obj));
}

// Paddle sending with client prediction
function sendPaddle(logicalX) {
  const now = Date.now();
  if (now - lastSendTs < SEND_THROTTLE) return;
  lastSendTs = now;
  const maxLeft = LOGICAL_W - 100;
  const clamped = Math.max(0, Math.min(maxLeft, logicalX));
  // update local render for smooth movement
  if (typeof playerId === 'number') renderPaddles[playerId].x = clamped;
  send({ type: 'paddle', x: +clamped.toFixed(2) });
}

// Input
document.addEventListener('mousemove', e => {
  if (!gameStarted) return;
  const lx = clientXToLogical(e.clientX);
  sendPaddle(lx - 50);
});
document.addEventListener('touchmove', e => {
  if (!gameStarted) return;
  e.preventDefault();
  const lx = clientXToLogical(e.touches[0].clientX);
  sendPaddle(lx - 50);
}, {passive:false});

// Interpolation
function interpolateState(renderTs) {
  if (stateBuffer.length === 0) return null;
  let i = 0;
  while (i < stateBuffer.length && stateBuffer[i].ts <= renderTs) i++;
  if (i === 0) return stateBuffer[0].state;
  if (i >= stateBuffer.length) return stateBuffer[stateBuffer.length - 1].state;
  const a = stateBuffer[i-1], b = stateBuffer[i];
  const t = (renderTs - a.ts) / Math.max(1, (b.ts - a.ts));
  const lerp = (v0, v1, t) => v0 + (v1 - v0) * t;
  return {
    ball: { x: lerp(a.state.ball.x, b.state.ball.x, t), y: lerp(a.state.ball.y, b.state.ball.y, t), r: a.state.ball.r },
    paddles: [
      { x: lerp(a.state.paddles[0].x, b.state.paddles[0].x, t), y: a.state.paddles[0].y, w: a.state.paddles[0].w, h: a.state.paddles[0].h },
      { x: lerp(a.state.paddles[1].x, b.state.paddles[1].x, t), y: a.state.paddles[1].y, w: a.state.paddles[1].w, h: a.state.paddles[1].h }
    ],
    scores: a.state.scores
  };
}

// Render loop
function drawLoop() {
  const ratio = window.devicePixelRatio || 1;
  const displayW = canvas.width / ratio;
  const displayH = canvas.height / ratio;
  ctx.clearRect(0,0,displayW,displayH);

  const scaleX = displayW / LOGICAL_W;
  const scaleY = displayH / LOGICAL_H;
  const offsetX = (displayW - LOGICAL_W * scaleX) / 2;
  const offsetY = (displayH - LOGICAL_H * scaleY) / 2;

  const renderTs = Date.now() - INTERP_MS;
  let drawState = gameState ? interpolateState(renderTs) : null;

  if (drawState) {
    renderBall.x = drawState.ball.x;
    renderBall.y = drawState.ball.y;

    // draw ball
    ctx.fillStyle = '#fff';
    ctx.beginPath();
    ctx.arc(offsetX + renderBall.x * scaleX, offsetY + renderBall.y * scaleY,
            Math.max(2, drawState.ball.r * Math.min(scaleX, scaleY)), 0, Math.PI*2);
    ctx.fill();

    // draw paddles
    drawState.paddles.forEach((p, i) => {
      if (typeof playerId === 'number' && i === playerId) {
        // predicted paddle
        renderPaddles[i].x += (renderPaddles[i].x - renderPaddles[i].x) * 0;
      } else {
        // smooth opponent
        renderPaddles[i].x += (p.x - renderPaddles[i].x) * 0.28;
      }
      renderPaddles[i].y = p.y;
      ctx.fillRect(offsetX + renderPaddles[i].x * scaleX, offsetY + renderPaddles[i].y * scaleY,
                   p.w * scaleX, p.h * scaleY);
    });

    // draw score
    ctx.fillStyle = '#fff';
    ctx.font = `${Math.max(12, Math.round(20 * Math.min(scaleX, scaleY)))}px Tahoma`;
    ctx.textAlign = 'center';
    ctx.fillText(`${drawState.scores[0]} - ${drawState.scores[1]}`, displayW/2, offsetY + 26);
  } else {
    ctx.fillStyle = '#fff';
    ctx.font = '16px Tahoma';
    ctx.textAlign = 'center';
    ctx.fillText('در انتظار شروع بازی...', displayW/2, displayH/2);
  }

  requestAnimationFrame(drawLoop);
}
requestAnimationFrame(drawLoop);

// Handle server messages
function onMessage(e) {
  let data;
  try { data = JSON.parse(e.data); } catch { return; }
  const t = data.type;

  if (t === 'assign') playerId = data.playerId;
  if (t === 'start') gameStarted = true;
  if (t === 'state') {
    const s = data.state;
    const serverTs = data.meta?.ts || Date.now();
    stateBuffer.push({ ts: serverTs, state: s });
    while (stateBuffer.length > 10) stateBuffer.shift();
    gameState = s;
  }
  if (t === 'ping') send({ type: 'pong', ts: Date.now() });
}
</script>
